Second patch suggestion to improve behavior of streamdev-client
when filters are enabled. In the original code, TimedWrite could
have correctly written Buffer but would still return failure (false)
because the time that the actual Write() call takes was taken
into account. On RPIs (single CPU core) it was observed that 
sel.Select() returned immediately (200 msec budget for writing
left), and then sometimes Write() would take more than 200 msec
(but succeed) due to competing threads/processes. And VDR would
then stop replaying the current program correctly.

With this fix, the time for the (final) Write() is not taken into
account for the timing check. This seems to make playback more
stable and less prone to failure.

diff -wcr a/tools/source.c b/tools/source.c
*** /data/installfiles/vdrplugins/vdr-plugin-streamdev/tools/source.c	2014-12-07 17:56:40.103787000 +0100
--- ./tools/source.c	2015-01-03 01:11:50.288197398 +0100
***************
*** 57,86 ****
  bool cTBSource::TimedWrite(const void *Buffer, size_t Length, uint TimeoutMs) {
  	cTBSelect sel;
  	int ms, offs;
- 
  	cTimeMs starttime;
! 	ms = TimeoutMs;
  	offs = 0;
  	sel.Clear();
  	sel.Add(m_Filed, true);
  	while (Length > 0) {
  		int b;
  
! 		if (sel.Select(ms) == -1)
  			return false;
  
  		if (sel.CanWrite(m_Filed)) {
! 			if ((b = Write((char*)Buffer + offs, Length)) == -1)
  				return false;
  			offs += b;
  			Length -= b;
  		}
  
- 		ms = TimeoutMs - starttime.Elapsed();
- 		if (ms <= 0) {
- 			errno = ETIMEDOUT;
- 			return false;
- 		}
  	}
  	return true;
  }
--- 57,92 ----
  bool cTBSource::TimedWrite(const void *Buffer, size_t Length, uint TimeoutMs) {
  	cTBSelect sel;
  	int ms, offs;
  	cTimeMs starttime;
! 
  	offs = 0;
  	sel.Clear();
  	sel.Add(m_Filed, true);
  	while (Length > 0) {
  		int b;
  
! 		ms = TimeoutMs - starttime.Elapsed();
! 		if (ms <= 0) {
!                         isyslog("cTBSource::TimedWrite: Timeout: %d [msec] (max: %d [msec])", starttime.Elapsed(), TimeoutMs);
!  
! 			errno = ETIMEDOUT;
! 			return false;
! 		}
! 
! 		if (sel.Select(ms) == -1) {
!                         isyslog("cTBSource::TimedWrite: sel.Select(%d) = -1", ms);
  			return false;
+                 }
  
  		if (sel.CanWrite(m_Filed)) {
! 			if ((b = Write((char*)Buffer + offs, Length)) == -1) {
!                                 isyslog("cTBSource::TimedWrite: Write(offset=%d,length=%d) = -1", offs, Length); 
  				return false;
+                         }
  			offs += b;
  			Length -= b;
  		}
  
  	}
  	return true;
  }
